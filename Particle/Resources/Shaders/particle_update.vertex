#version 410 core

layout (location = 0) in vec3 inPosition;
layout (location = 1) in vec3 inVelocity;
layout (location = 2) in vec4 inColor;
layout (location = 3) in float inLifespan;
layout (location = 4) in float inMass;

out vec3 outPosition;
out vec3 outVelocity;
out vec4 outColor;
out float outLifespan;
out float outMass;

uniform double dt;
uniform samplerBuffer tbo_id;
uniform vec2 speed_limit; // x: Min Speed, y: Max Speed
uniform vec4 grid_data; // x: Rows, y: Columns, z: Size X, w: Size Y
uniform float dragCoefficient;

#define GD grid_data
#define ROWS GD.x
#define COLS GD.y
#define SIZE_ROW GD.z
#define SIZE_COL GD.w

#define SL speed_limit
#define MIN_SPEED SL.x
#define MAX_SPEED SL.y

vec3 CalculateDrag();
vec4 SampleForceTexture();
int  SampleIndex(int modX, int modY);
void CheckBounds();

void main()
{
    vec4 textureSample = SampleForceTexture();
    vec3 drag = CalculateDrag();
    //vec3 drag = vec3(0, 0, 0);
    vec3 calculatedVelocity = vec3(
        clamp(inVelocity.x + textureSample.x - drag.x, MIN_SPEED, MAX_SPEED),
        clamp(inVelocity.y + textureSample.y - drag.y, MIN_SPEED, MAX_SPEED),
        clamp(inVelocity.z + textureSample.z - drag.z, MIN_SPEED, MAX_SPEED)
    );

    outPosition = inPosition + calculatedVelocity;
    CheckBounds();

    // float alpha = ( (inPosition.x < 0 || inPosition.x > COLS * SIZE_COL) || (inPosition.y > 0 || inPosition.y < -ROWS * SIZE_ROW)  ) ? 0 : 1;
    // outColor = vec4(calculatedVelocity.xyz, 1);
    // outColor = vec4(inColor.xyz, alpha);
    outColor = inColor;


    // These values are simply passed through... 
    outVelocity = calculatedVelocity;
    outLifespan = inLifespan;
    outMass = inMass;
}

vec3 CalculateDrag()
{
    float speed = length(inVelocity);
    float dragSpeed = dragCoefficient * speed * speed;
    vec3 drag = inVelocity.xyz * -1;
    drag = normalize(drag) * (dragCoefficient * speed * speed);
    return vec3(drag.x, drag.y, 0);
}

vec4 SampleForceTexture()
{
    vec4 textureSample;
    float sampleStrength = 0.5;
    float samples = 3;

    // Sample of current cell - Strength 100%.
    textureSample = texelFetch(tbo_id, SampleIndex(0, 0));


    // Immediate Samples (+/- 1 step, at 50% strength of previous sample level)
    for(int i = 1; i <= samples; ++i)
    {
        textureSample += (texelFetch(tbo_id, SampleIndex( 0,  i)) * samples); // Top
        textureSample += (texelFetch(tbo_id, SampleIndex(-i,  0)) * samples); // Left
        textureSample += (texelFetch(tbo_id, SampleIndex( i,  0)) * samples); // Right
        textureSample += (texelFetch(tbo_id, SampleIndex( 0, -i)) * samples); // Bottom

        textureSample += (texelFetch(tbo_id, SampleIndex(-i,  i)) * samples); // Top Left
        textureSample += (texelFetch(tbo_id, SampleIndex( i,  i)) * samples); // Top Right
        textureSample += (texelFetch(tbo_id, SampleIndex(-i, -i)) * samples); // Bottom Left
        textureSample += (texelFetch(tbo_id, SampleIndex( i, -i)) * samples); // Bottom Right

        sampleStrength *= 0.5;
    }

    return textureSample;
}

int SampleIndex(int modX, int modY)
{
    return int( int(    (inPosition.x + modX) / SIZE_ROW) * COLS + int( (inPosition.y + modY) / SIZE_COL) );
}

void CheckBounds()
{
    if (outPosition.x > COLS * SIZE_COL) outPosition.x = 0;
    if (outPosition.y < -ROWS * SIZE_ROW) outPosition.y = 0;

    if (outPosition.x < 0 ) outPosition.x = COLS * SIZE_COL;
    if (outPosition.y > 0) outPosition.y = -ROWS * SIZE_ROW;
}
