#version 410 core

layout (location = 0) in vec3 inPosition;
layout (location = 1) in vec3 inVelocity;
layout (location = 2) in vec4 inColor;
layout (location = 3) in float inLifespan;
layout (location = 4) in float inMass;

out vec3 outPosition;
out vec3 outVelocity;
out vec4 outColor;
out float outLifespan;
out float outMass;

uniform float dt;
uniform samplerBuffer tbo_id0;
uniform samplerBuffer tbo_id1;

uniform vec2 minMaxSpeed; // x: Min, y: Max
uniform int resolution;
uniform vec3 dimensions;
uniform float dragCoefficient;
uniform float gravity;
uniform int samples;
uniform float sampleStrength;
uniform float sampleStengthDegradation;

#define GD dimensions
#define SL minMaxSpeed
#define SIZE resolution

#define X GD.x
#define Y GD.y
#define Z GD.z

#define SIZE_X X * SIZE
#define SIZE_Y Y * SIZE
#define SIZE_Z Z * SIZE

#define MIN_SPEED SL.x
#define MAX_SPEED SL.y

vec3 CalculateDrag();
vec3 ApplyDrag(vec3 _drag, vec3 _velocity);
vec4 SampleForceTexture(samplerBuffer sampler);
int SampleIndex(int x, int y, int z);
void CheckBounds();

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main()
{
    vec4 textureSample;

    textureSample = SampleForceTexture(tbo_id0);
    vec3 drag = CalculateDrag();
    float gravityModifier = 1.0 * map(inPosition.y, 0.0, (SIZE_Y + SIZE), 0.0, 1.0); // Want gravity to pull harder the higher it is!
    vec3 calculatedVelocity = vec3(
        clamp(inVelocity.x + textureSample.x, MIN_SPEED, MAX_SPEED) * dt,
        clamp(inVelocity.y + textureSample.y - ((gravity + gravityModifier) * inMass), MIN_SPEED, MAX_SPEED) * dt,
        clamp(inVelocity.z + textureSample.z, MIN_SPEED, MAX_SPEED) * dt
    );
    calculatedVelocity = ApplyDrag(drag, calculatedVelocity);

    outPosition = inPosition + calculatedVelocity;
    CheckBounds();

    // outColor = vec4(calculatedVelocity.xyz, 1);
    outColor = inColor;

    // These values are simply passed through... 
    outVelocity = calculatedVelocity;
    outLifespan = inLifespan;
    outMass = inMass;
}

vec3 CalculateDrag()
{
    float speed = length(inVelocity);
    float dragSpeed = dragCoefficient * speed * speed;
    vec3 drag = inVelocity * -1;
    drag = normalize(drag) * (dragCoefficient * speed * speed);
    return vec3(drag.x, drag.y, drag.z);
}

vec3 ApplyDrag(vec3 _drag, vec3 _velocity)
{
    vec3 newVelocity = _velocity;

    if (newVelocity.x >= 0 && newVelocity.x - _drag.x < 0.0) newVelocity.x = 0.0;
    else newVelocity.x -= _drag.x;

    if (newVelocity.y >= 0 && newVelocity.y - _drag.y < 0.0) newVelocity.y = 0.0;
    else newVelocity.y -= _drag.y;

    if (newVelocity.z >= 0 && newVelocity.z - _drag.z < 0.0) newVelocity.z = 0.0;
    else newVelocity.z -= _drag.z;

    return newVelocity;

}

vec4 SampleForceTexture(samplerBuffer sampler)
{
    vec4 textureSample;
    float ss = sampleStrength;

    textureSample += (texelFetch(sampler, SampleIndex(0, 0, 0)));
    ss * sampleStengthDegradation;

    for(int i = 1; i <= samples; ++i)
    {
        if (inPosition.y < SIZE_Y)
        {
            textureSample += (texelFetch(sampler, SampleIndex( 1,  0,  i))); // Above Top
            textureSample += (texelFetch(sampler, SampleIndex( 1, -i,  0))); // Above Left
            textureSample += (texelFetch(sampler, SampleIndex( 1,  i,  0))); // Above Right
            textureSample += (texelFetch(sampler, SampleIndex( 1,  0, -i))); // Above Bottom
        }

        textureSample += (texelFetch(sampler, SampleIndex( 0,  0,  i))); // Top
        textureSample += (texelFetch(sampler, SampleIndex( 0, -i,  0))); // Left
        textureSample += (texelFetch(sampler, SampleIndex( 0,  i,  0))); // Right
        textureSample += (texelFetch(sampler, SampleIndex( 0,  0, -i))); // Bottom

        if (inPosition.y >= SIZE)
        {
            textureSample += (texelFetch(sampler, SampleIndex(-1,  0,  i))); // Below Top
            textureSample += (texelFetch(sampler, SampleIndex(-1, -i,  0))); // Below Left
            textureSample += (texelFetch(sampler, SampleIndex(-1,  i,  0))); // Below Right
            textureSample += (texelFetch(sampler, SampleIndex(-1,  0, -i))); // Below Bottom
        }

        // textureSample += (texelFetch(sampler, SampleIndex(-i,  i))); // Top Left
        // textureSample += (texelFetch(sampler, SampleIndex( i,  i))); // Top Right
        // textureSample += (texelFetch(sampler, SampleIndex(-i, -i))); // Bottom Left
        // textureSample += (texelFetch(sampler, SampleIndex( i, -i))); // Bottom Right

        ss *= sampleStengthDegradation;
    }

    return textureSample;
}

int SampleIndex(int x, int y, int z)
{   
    // return int(int((inPosition.y + y) / SIZE_Y) * Y) + int(int((inPosition.z + z) / SIZE_Z) * Z) + int(int(inPosition.x + x) / SIZE_X);

    return int(int((inPosition.y + y) / SIZE_Y)) + int(int((inPosition.z + z) / SIZE_Z)) + int(int(inPosition.x + x) / SIZE_X);
}

void CheckBounds()
{
    if (outPosition.x > SIZE_X) outPosition.x = 0;
    if (outPosition.x < 0) outPosition.x = SIZE_X;

    if (outPosition.z > SIZE_Z) outPosition.z = 0;
    if (outPosition.z < 0) outPosition.z = SIZE_Z;

    if (outPosition.y < 0) outPosition.y = 0;
}
